"use strict";(self.webpackChunkng_games=self.webpackChunkng_games||[]).push([[592],{6695:(g,m,f)=>{f.d(m,{d:()=>p,M:()=>o});var r=f(8306);const p={back:e=>Math.pow(e,2)*(1.5*e-.5),bounce:e=>{for(let t=0,i=1;;t+=i,i/=2)if(e>=(7-4*t)/11)return-Math.pow((11-6*t-11*e)/4,2)+Math.pow(i,2);return 0},circ:e=>1-Math.sin(Math.acos(e)),elastic:(e,t)=>Math.pow(2,10*(t-1))*Math.cos(20*Math.PI*e/3*t),linear:e=>e,makeEaseOut:e=>t=>1-e(1-t),quad:e=>Math.pow(e,2)};class o{static getRandomInt(t,i){return Math.floor(Math.random()*(i-t+1))+t}static animate({timing:t,draw:i,duration:a}){const d=performance.now(),n=c=>{let s=(c-d)/a;s>1&&(s=1);const l=t(s);i(l),s<1&&requestAnimationFrame(n)};requestAnimationFrame(n)}static numberFormat(t,i=0,a=".",d=" "){let n,c,s="",l="";t<0&&(l="-",t*=-1),isNaN(i=Math.abs(i))&&(i=2);const u=String(t).split(".");return n=""+u[0],c=n.split(/(?=(?:\d{3})+$)/).join(d),void 0!==u[1]&&i>0&&(s=a+u[1].slice(0,i)),l+c+s}static isRectangleCollision(t,i){return t.x+t.width>=i.x&&t.x<=i.x+i.width&&t.y+t.height>=i.y&&t.y<=i.y+i.height}static uploadImage(){return new r.y(t=>{const i=document.createElement("input");i.setAttribute("type","file"),i.setAttribute("accept","image/*"),i.addEventListener("change",()=>{var a;i&&1===(null===(a=i.files)||void 0===a?void 0:a.length)?(t.next(i.files[0]),t.complete()):t.error("\u041d\u0435 \u0431\u043e\u043b\u044c\u0448\u0435 \u043e\u0434\u043d\u043e\u0433\u043e \u0444\u0430\u0439\u043b\u0430 \u0437\u0430 \u0440\u0430\u0437")},{once:!0}),i.click()})}}},7268:(g,m,f)=>{f.d(m,{k:()=>r});class r{static isRectangleCollision(o,e){return!(o.x>=e.x+e.width||o.x+e.width<e.x||o.y>=e.y+e.height||o.y+o.height<e.y)}static pointInRect(o,e){return o.x>=e.x&&o.x<=e.x+e.width&&o.y>=e.y&&o.y<=e.y+e.height}static lineIntersect(o,e){const t=o.p1.x,i=o.p1.y,a=o.p2.x,d=o.p2.y,n=e.p1.x,c=e.p1.y,s=e.p2.x,l=e.p2.y,u=(l-c)*(a-t)-(s-n)*(d-i);if(0==u)return null;const v=((s-n)*(i-c)-(l-c)*(t-n))/u,x=((a-t)*(i-c)-(d-i)*(t-n))/u;return{x:t+v*(a-t),y:i+v*(d-i),seg1:v>=0&&v<=1,seg2:x>=0&&x<=1}}static angleOfVector(o){let e=Math.acos(o.x);return o.y<0&&(e=Math.PI+Math.PI-e),r.rad2grad(e)}static angleVector(o){const e=r.grad2rad(o);return{x:Math.cos(e),y:Math.sin(e)}}static grad2rad(o){return o*Math.PI/180}static rad2grad(o){return 180/Math.PI*o}}},6797:(g,m,f)=>{f.d(m,{V3:()=>t,pM:()=>o});var r=f(8977);class o{static getShaderMesh(a,d){const n=(new r.ZXM).addAttribute("aVertexPosition",[-1,3,-1,-1,3,-1]),u=r.exe.from("\n      attribute vec2 aVertexPosition;\n      void main(void) {\n        gl_Position = vec4(aVertexPosition, 1.0, 1.0);\n      }\n    ","\n  #define TAU 6.28318530718\n  #define MAX_ITER 5\n\n  uniform float iTime;\n  uniform vec2 iResolution;\n\n  void main() {\n    float time = iTime * .5+23.0;\n    // uv should be the 0-1 uv of texture...\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  #ifdef SHOW_TILING\n    vec2 p = mod(uv*TAU*2.0, TAU)-250.0;\n  #else\n    vec2 p = mod(uv*TAU, TAU)-250.0;\n  #endif\n    vec2 i = vec2(p);\n    float c = 1.0;\n    float inten = .005;\n\n    for (int n = 0; n < MAX_ITER; n++) {\n      float t = time * (1.0 - (3.5 / float(n+1)));\n      i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n      c += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\n    }\n    c /= float(MAX_ITER);\n    c = 1.17-pow(c, 1.4);\n    vec3 colour = vec3(pow(abs(c), 8.0));\n    colour = clamp(colour + vec3(0.0, 0.35, 0.5), 0.0, 1.0);\n\n  #ifdef SHOW_TILING\n    // Flash tile borders...\n    vec2 pixel = 2.0 / iResolution.xy;\n    uv *= 2.0;\n\n    float f = floor(mod(iTime*.5, 2.0)); \t// Flash value.\n    vec2 first = step(pixel, uv) * f;\t\t   \t// Rule out first screen pixels and flash.\n    uv  = step(fract(uv), pixel);\t\t\t\t// Add one line of pixels per tile.\n    colour = mix(colour, vec3(1.0, 1.0, 0.0), (uv.x + uv.y) * first.x * first.y); // Yellow line\n  #endif\n    gl_FragColor = vec4(colour, 1.0);\n  }\n",{iResolution:{x:a,y:d,z:1},iTime:0});return new r.Kj0(n,u)}}class t{static getShaderMesh(a,d){const n=(new r.ZXM).addAttribute("aVertexPosition",[-1,3,-1,-1,3,-1]),u=r.exe.from("\n      attribute vec2 aVertexPosition;\n      void main(void) {\n        gl_Position = vec4(aVertexPosition, 1.0, 1.0);\n      }\n    ","\n    precision mediump float;\n    uniform float iTime;\n    varying lowp vec4 fragCoord;\n    uniform vec2 iResolution;\n\n    #define iterations 13 // 17\n    #define formuparam 0.53\n\n    #define volsteps 30 // 20\n    #define stepsize 0.1\n\n    #define zoom   0.800 // 0.800\n    #define tile   0.550 // 0.850\n    #define speed  0.010 // 0.010\n\n    #define brightness 0.0015\n    #define darkmatter 0.300\n    #define distfading 0.730\n    #define saturation 0.850\n    void main() {\n        //get coords and direction\n        vec2 uv = gl_FragCoord.xy / iResolution.xy-.5;\n        uv.y *= iResolution.y / iResolution.x;\n        vec3 dir = vec3(uv*zoom, 1.);\n        float time = iTime * speed + .25;\n\n        vec3 from = vec3(1., .5, 0.5);\n        from += vec3(time * 2., time, -2.);\n\n        //volumetric rendering\n        float s= 0.1, fade = 1.;\n        vec3 v = vec3(0.);\n        for (int r = 0; r < volsteps; r++) {\n            vec3 p = from + s * dir * .5;\n            p = abs(vec3(tile) - mod(p, vec3(tile * 2.))); // tiling fold\n            float pa, a = pa = 0.;\n            for (int i = 0; i < iterations; i++) {\n                p = abs(p) / dot(p,p) - formuparam; // the magic formula\n                a += abs(length(p) - pa); // absolute sum of average change\n                pa = length(p);\n            }\n            float dm = max(0., darkmatter - a * a * .001); //dark matter\n            a *= a * a; // add contrast\n            if (r > 6) fade *= 1. - dm; // dark matter, don't render near\n            //v += vec3(dm, dm * .5, 0.);\n            v +=fade;\n            v += vec3(s, s * s, s * s * s * s) * a * brightness * fade; // coloring based on distance\n            fade *= distfading; // distance fading\n            s += stepsize;\n        }\n        v = mix(vec3(length(v)), v, saturation); //color adjust\n        gl_FragColor = vec4(v * .01, 1.);\n    }\n",{iResolution:{x:a,y:d,z:1},iTime:0});return new r.Kj0(n,u)}}}}]);